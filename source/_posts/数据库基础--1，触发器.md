---
title: 数据库基础--1，触发器
date: 2017-09-27 13:48:54
toc: true
comment: true
tags:
 - 数据库
---

mysql trigger: 官方文档： [https://dev.mysql.com/doc/refman/5.7/en/create-trigger.html](https://dev.mysql.com/doc/refman/5.7/en/create-trigger.html "https://dev.mysql.com/doc/refman/5.7/en/create-trigger.html")

看下Mysql文档对于触发器的说明：

>A trigger is a named database object that is associated with a table, and that activates when a particular event occurs for the table. Trigger names exist in the schema namespace, meaning that all triggers must have unique names within a schema. Triggers in different schemas can have the same name.

数据库的触发器，是一个和数据库的持久化的表相关联的，被命名的，当关联的表发生特定事件的时候触发操作的一个数据库对象。和触发器相关联的，必须是持久表，不能是临时表或者视图，同一个  **Schema NameSpace** 下的触发器用名字来标识，不同  **Schema Namespace** 之下的触发器名字可以相同。

在mysql中，**Schema** 和  **Database** 是没有区别的， **CREATE DATABASE** 和 **CREATE SCHEMA** 作用是等价的，mysql自带的mysql workbench 创建数据库使用的就是 **CREATE SCHEMA** ，简单的说，就是不同数据库下的触发器命名可以相同，同一个数据库下的触发器命名不可以相同。

<!--more-->

## 一，创建触发器的语法

``` sql

CREATE
    [DEFINER = { user | CURRENT_USER }]
    TRIGGER trigger_name
    trigger_time trigger_event
    ON tbl_name FOR EACH ROW
    [trigger_order]
    trigger_body

trigger_time: { BEFORE | AFTER }

trigger_event: { INSERT | UPDATE | DELETE }

trigger_order: { FOLLOWS | PRECEDES } other_trigger_name

```
| 语法          | 简单解释                                                                                                                                                             |
|:------------- |:-------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| DEFINER       | 默认的是定义触发器的用户，没有超级权限的用户只能CREATE TRIGGER的时候只能使用自己，root用户可以指定其他用户，用途是对于检查执行的触发内容 DEFINER有没有相应的访问权限 |
| tbl_name      | 和触发器相关联的表                                                                                                                                                   |
| trigger_order | mysql5.7之后支持同一张表同一个动作关联多个触发器，触发器的执行顺序默认是触发器定义的顺序，使用过trigger_order显式说明当前创建的触发器执行顺序在某个相同动作的触发器之前或者之后                                                                             |
| trigger_body  | 触发器执行的具体逻辑                                                                                                                                                 |


需要特别说明的是：  **trigger_event** 中的  **INSERT** 指的是任何导致表行数增加的操作，例如:  **INSERT** ,  **LOAD DATA** ,  **REPLACE** 等，  **DELETE** 指的是任何删除表中行的操作，例如  **DELETE** , **REPLACE** ，但是  **DROP TABLE** 和  **TRUNCATE TABLE** 不会触发删除操作。

简单的创建触发器的语句：

1. `CREATE TABLE account (acct_num INT, amount DECIMAL(10,2));` 建表
2. `CREATE TRIGGER ins_sum BEFORE INSERT ON account FOR EACH ROW SET @sum = @sum + NEW.amount;` 创建一个计算总插入数值的触发器
3. `SET @sum = 0;`
4. `INSERT INTO account VALUES(137,14.98),(141,1937.50),(97,-100.00);` 插入数据
5. `SELECT @sum AS 'Total amount inserted';` 获取结果
6. `DROP TRIGGER test.ins_sum;` 使用  **数据库名.触发器名** 的格式来删除触发器

 ## 二，触发器执行内容的语法

 ### 1，使用NEW和OLD

 在不同的操作之下，我们可以使用  **NEW.属性** 和  **OLD.属性** 来表示更新表之前的某个属性值和更新表之后的某个属性值。

-  **INSERT** 的触发器操作下，可以使用  **NEW.col_name**
-  **UPDATE** 操作，使用  **OLD.col_name** 和  **NEW.col_name** 都可以
-  **DELETE** 操作，只能使用  **OLD.col_name**

### 2，使用 BEGIN...END 架构

使用  **BEGIN ... END** 架构，可以在触发器内容中进行一些复杂的逻辑判断，官方给出的例子：

![sql begin end](http://photos.zengxihao.xyz/82f7470666c7575e6b5ed5e0d5c806c2.png)

### 3，调用存储过程

在触发体中使用  **CALL** 关键字调用存储过程，但是调用存储过程存在两个限制：

1. 直接返回结果给client用户的不能调用（但是可以通过调用存储过程返回结果给触发器体）
2. 触发器体不能显式或隐式地开始或结束事务

### 4，使用其他表的引用

触发器体中可以使用其他表的引用，例如：

![](http://photos.zengxihao.xyz/c7aee989e2fa6028667ce9ce7a402736.png)


## 三，结尾

写着写着发现其实没有什么意思，触发器就是很简单的一个数据库内容，自己看文档或者博客都可以入门。

有点意兴阑珊地结束。
